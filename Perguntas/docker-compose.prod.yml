services:
  db:
    image: mariadb:11.4
    restart: unless-stopped
    environment:
      MARIADB_DATABASE: ${DB_NAME:-samu_q}
      MARIADB_USER: ${DB_USER:-samu_q}
      MARIADB_PASSWORD: ${DB_PASSWORD:-change-me}
      # Senha root separada da senha do usuário de aplicação
      MARIADB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-root-change-me}
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      # Usa o cliente 'mariadb' (binário padrão) e a senha root correta (MARIADB_ROOT_PASSWORD)
      # IMPORTANTE: usar $$ para evitar expansão pelo host; dentro do container vira $.
      test: ["CMD-SHELL", "mariadb -uroot -p$$MARIADB_ROOT_PASSWORD -e 'SELECT 1' 2>/dev/null || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 15
      start_period: 25s

  web:
    # Se APP_IMAGE estiver definido no ambiente, usamos a imagem já publicada (pull-based deploy)
    # Caso contrário, docker compose fará build local usando Dockerfile.prod.
    # Em produção (EC2) recomenda-se definir APP_IMAGE=ghcr.io/caiooliveirac/samu-normas:TAG_IMUTAVEL
    # e opcionalmente remover/ignorar a seção 'build' abaixo para evitar builds acidentais.
    image: ${APP_IMAGE:-}
    build:
      context: .
      dockerfile: Dockerfile.prod
    env_file:
      - .env.prod
    environment:
      DJANGO_SETTINGS_MODULE: samu_q.settings
      # As demais variáveis vêm de .env.prod; aqui só forçamos defaults críticos se faltarem.
      DB_HOST: db
      DB_PORT: 3306
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.connect((\"127.0.0.1\",8000)); s.close(); print(\"ok\")'"]
      interval: 30s
      timeout: 5s
      retries: 5
    command: ["/bin/sh", "-c", "./scripts/entrypoint.prod.sh"]

  nginx:
    image: nginx:1.27-alpine
    depends_on:
      - web
    ports:
      - "8000:80"    # Porta HTTP (redirect)
      - "8443:443"   # Expondo HTTPS (alterar para 443:443 em produção definitiva)
    volumes:
      - static_volume:/app/staticfiles:ro
      - media_volume:/app/media:ro
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      # Volume de certificados (estrutura padrão do certbot: /certs/live/DOMINIO/*.pem)
      - certs_volume:/certs:ro
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://127.0.0.1/nginx-health || exit 1"]
      interval: 20s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Serviço opcional para obtenção/renovação de certificados Let's Encrypt
  # Uso típico (primeira emissão - staging):
  # docker compose run --rm certbot certonly --webroot -w /var/www/certbot -d SEU_DOMINIO --email SEU_EMAIL --agree-tos --no-eff-email --staging
  # Depois ajustar default.conf com o domínio real e reiniciar nginx.
  certbot:
    image: certbot/certbot:latest
    volumes:
      - certs_volume:/etc/letsencrypt
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
    entrypoint: ["/bin/sh", "-c", "echo 'Use docker compose run --rm certbot ...' && sleep 5"]

volumes:
  db_data:
  static_volume:
  media_volume:
  certs_volume:
