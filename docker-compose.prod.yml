services:
  # Build rápido do frontend (sem rebuild da imagem web).
  # Uso (manual):
  #   docker compose -f docker-compose.prod.yml run --rm frontend
  # Ele escreve os assets no volume react_volume, que é montado em web/nginx.
  frontend:
    image: node:24-alpine
    working_dir: /frontend
    environment:
      # Garante base correta no build caso alguém mude o vite.config
      VITE_BASE: /static/react/
    volumes:
      - ./frontend:/frontend
      - frontend_node_modules:/frontend/node_modules
      - frontend_npm_cache:/root/.npm
      - react_volume:/out
    command:
      - /bin/sh
      - -c
      - |
        set -e
        echo "[frontend] Instalando deps (inclui devDependencies para o build)..."
        cd /frontend
        npm install
        echo "[frontend] Limpando /out..."
        find /out -mindepth 1 -maxdepth 1 -exec rm -rf {} +
        echo "[frontend] Build Vite -> /out"
        npm run build -- --outDir /out

  db:
    image: mariadb:11.4
    restart: unless-stopped
    # Usa as mesmas variáveis definidas em .env.prod (DB_NAME, DB_USER, DB_PASSWORD, DB_ROOT_PASSWORD)
    env_file:
      - .env.prod
    environment:
      MARIADB_DATABASE: ${DB_NAME:-samu_q}
      MARIADB_USER: ${DB_USER:-samu_q}
      MARIADB_PASSWORD: ${DB_PASSWORD:-change-me}
      # Senha root separada da senha do usuário de aplicação
      MARIADB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD:-root-change-me}
    volumes:
      - db_data:/var/lib/mysql
    healthcheck:
      # Usa o cliente 'mariadb' (binário padrão) e a senha root correta (MARIADB_ROOT_PASSWORD)
      # IMPORTANTE: usar $$ para evitar expansão pelo host; dentro do container vira $.
      test: ["CMD-SHELL", "mariadb -uroot -p$$MARIADB_ROOT_PASSWORD -e 'SELECT 1' 2>/dev/null || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 15
      start_period: 25s

  web:
    # Se APP_IMAGE estiver definido no ambiente, usamos a imagem já publicada (pull-based deploy)
    # Caso contrário, docker compose fará build local usando Dockerfile.prod.
    # Em produção (EC2) recomenda-se definir APP_IMAGE=ghcr.io/caiooliveirac/samu-normas:TAG_IMUTAVEL
    # e opcionalmente remover/ignorar a seção 'build' abaixo para evitar builds acidentais.
    # Dica rápida:
    #   APP_IMAGE=ghcr.io/caiooliveirac/samu-normas:<sha> docker compose -f docker-compose.prod.yml up -d --no-build web
    # Se alterar variáveis de ambiente críticas (ex: SECRET_KEY, DB_*), use --force-recreate ou o script ./scripts/deploy.sh
    image: ${APP_IMAGE:-}
    build:
      context: .
      dockerfile: Dockerfile.prod
      args:
        BUILD_SHA: ${BUILD_SHA:-dev-local}
        BUILD_DATE: ${BUILD_DATE:-unknown}
        APP_VERSION: ${APP_VERSION:-dev}
    env_file:
      - .env.prod
    environment:
      DJANGO_SETTINGS_MODULE: samu_q.settings
      # As demais variáveis vêm de .env.prod; aqui só forçamos defaults críticos se faltarem.
      DB_HOST: db
      DB_PORT: 3306
    depends_on:
      db:
        condition: service_healthy
    volumes:
      - static_volume:/app/staticfiles # Atenção: volume vazio na 1a subida sobrepõe assets empacotados; guard no entrypoint repopula
      # Assets do React (separado) — permite atualizar o front sem rebuild da imagem web.
      - react_volume:/app/static/react:ro
      - react_volume:/app/staticfiles/react:ro
      - media_volume:/app/media
    healthcheck:
      test: ["CMD-SHELL", "python -c 'import socket; s=socket.socket(); s.connect((\"127.0.0.1\",8000)); s.close(); print(\"ok\")'"]
      interval: 30s
      timeout: 5s
      retries: 5
    command: ["/bin/sh", "-c", "./scripts/entrypoint.prod.sh"]

  nginx:
    image: nginx:1.27-alpine
    depends_on:
      - web
    ports:
      - "80:80"      # Porta HTTP
      - "443:443"    # Porta HTTPS
    volumes:
      - static_volume:/app/staticfiles:ro
      # Fixa o tema das páginas Django (/ask,/login,/inbox): evita regressão para CSS antigo
      # quando o container web é recriado sem rebuild e repopula o volume staticfiles.
      - ./static/css/ask.css:/app/staticfiles/css/ask.css:ro
      # React build (volume separado)
      - react_volume:/app/staticfiles/react:ro
      # Anexos (imagens) - publicados via /anexos/
      - ./docs/anexos:/app/docs/anexos:ro
      - media_volume:/app/media:ro
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
      # Volume de certificados (estrutura padrão do certbot: /certs/live/DOMINIO/*.pem)
      - certs_volume:/certs:ro
    healthcheck:
      test: ["CMD-SHELL", "wget -q -O /dev/null http://127.0.0.1/nginx-health || exit 1"]
      interval: 20s
      timeout: 5s
      retries: 5
      start_period: 10s

  # Serviço opcional para obtenção/renovação de certificados Let's Encrypt
  # Uso típico (primeira emissão - staging):
  # docker compose run --rm certbot certonly --webroot -w /var/www/certbot -d SEU_DOMINIO --email SEU_EMAIL --agree-tos --no-eff-email --staging
  # Depois ajustar default.conf com o domínio real e reiniciar nginx.
  certbot:
    image: certbot/certbot:latest
    volumes:
      - certs_volume:/etc/letsencrypt
      - ./nginx/default.conf:/etc/nginx/conf.d/default.conf:ro
    entrypoint: ["/bin/sh", "-c", "echo 'Use docker compose run --rm certbot ...' && sleep 5"]

volumes:
  db_data:
  static_volume:
  react_volume:
  media_volume:
  certs_volume:
  frontend_node_modules:
  frontend_npm_cache:

